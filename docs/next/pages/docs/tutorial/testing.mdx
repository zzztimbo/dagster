<h1 id="testing-solids-and-pipelines">Testing solids and pipelines</h1>
<p>Our first solid and pipeline wouldn't be complete without some tests to ensure they're working as expected. We'll use :py<code class="interpreted-text" role="func">execute_pipeline</code> to test our pipeline, as well as :py<code class="interpreted-text" role="func">execute_solid</code> to test our solid in isolation.</p>
<p>These functions synchronously execute a pipeline or solid and return results objects (the :py<code class="interpreted-text" role="class">SolidExecutionResult</code> and :py<code class="interpreted-text" role="class">PipelineExecutionResult</code>) whose methods let us investigate, in detail, the success or failure of execution, the outputs produced by solids, and (as we'll see later) other events associated with execution.</p>
<div class="literalinclude" data-linenos="" data-caption="hello_cereal.py" data-lineno-start="31" data-lines="31-40" data-language="python">
<p>../../../examples/dagster_examples/intro_tutorial/hello_cereal.py</p>
</div>
<p>Now you can use pytest, or your test runner of choice, to run unit tests as you develop your data applications.</p>
<pre class="console"><code>$ pytest hello_cereal.py</code></pre>
<p>Note: by convention, pytest tests are typically kept in separate files prefixed with <code>test_</code>. We've put them in the same file just to simplify the tutorial code.</p>
<p>Obviously, in production we'll often execute pipelines in a parallel, streaming way that doesn't admit this kind of API, which is intended to enable local tests like this.</p>
<p>Dagster is written to make testing easy in a domain where it has historically been very difficult. Throughout the rest of this tutorial, we'll explore the writing of unit tests for each piece of the framework as we learn about it.</p>
